#!/usr/bin/env/python

from curses import wrapper, echo, noecho, cbreak, nocbreak, newwin, error
from pexpect import spawn, EOF
from subprocess import run, PIPE
from sys import argv

from pomodoro import PomodoroTimer, State


SYNC_MSG = 'Syncing task server...'


def run_task(arg_list=[]):
    return run(['task'] + arg_list, stdout=PIPE)


def newborderedwin(height, width, start_y, start_x):
    borderedwindow = newwin(height, width, start_y, start_x)
    borderedwindow.clear()
    borderedwindow.border()
    borderedwindow.refresh()

    return newwin(height - 2, width - 2, start_y + 1, start_x + 1)


def sync(display_function=print):
    try:
        display_function(SYNC_MSG)
        run_task(['sync'])
    except KeyboardInterrupt:
        pass


def toggle_timer(windrawer, timer):
    timer.toggle()
    windrawer.manage_wifi(timer.is_running, timer.state)


def next_phase(windrawer, timer):
    timer.next_phase()
    windrawer.manage_wifi(timer.is_running, timer.state)


class WinDrawer():
    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.password = None
        self.draw_windows()

    def input_char(self):
        self.textbox_window.clear()
        return self.textbox_window.getkey(*self.textbox_window.getyx())

    def write_status(self, status):
        self.status_window.clear()
        self.status_window.addstr(status)
        self.status_window.refresh()

    def input_sequence(self, status):
        self.write_status(status + " and press Ctrl-Enter when done (or "
                          "Ctrl-C to cancel)")
        self.textbox_window.clear()
        echo()
        nocbreak()

        try:
            key_sequence = self.textbox_window.getstr(
                *self.textbox_window.getyx())
        finally:
            noecho()
            cbreak()
        return key_sequence

    def input_taskids(self):
        ids = self.input_sequence("Enter the task's ids")

        while True:
            try:
                list(map(int, ids))
                return ids
            except ValueError:
                ids = self.input_sequence("Please enter valid ids")

    def draw_windows(self):
        self.stdscr.refresh()

        MAX_Y, MAX_X = self.stdscr.getmaxyx()
        STATUS_WINDOW_HEIGHT = 5
        TEXTBOX_WINDOW_HEIGHT = 4
        TASK_WINDOW_HEIGHT = (MAX_Y - STATUS_WINDOW_HEIGHT
                              - TEXTBOX_WINDOW_HEIGHT)

        self.task_window = newborderedwin(TASK_WINDOW_HEIGHT, MAX_X - 1,
                                          0, 0)
        self.status_window = newborderedwin(STATUS_WINDOW_HEIGHT, MAX_X - 1,
                                            TASK_WINDOW_HEIGHT, 0)
        self.textbox_window = newborderedwin(TEXTBOX_WINDOW_HEIGHT, MAX_X - 1,
                                             TASK_WINDOW_HEIGHT
                                             + STATUS_WINDOW_HEIGHT, 0)

        self.refresh_tasks()

    def refresh_tasks(self):
        self.task_window.clear()
        tasks = run_task().stdout.decode('utf-8').split("\n")

        try:
            for y, task in enumerate(tasks):
                self.task_window.addstr(y, 1, task)
        except error:
            pass

        self.task_window.refresh()

    def add(self):
        name = self.input_sequence("Enter the new task's data")
        run_task(['add'] + name.split())

    def delete(self):
        ids = self.input_taskids()
        run_task([ids, 'delete', 'rc.confirmation=off'])

    def modify(self):
        ids = self.input_taskids()
        name = self.input_sequence("Enter the modified task's data")
        run_task([ids, 'modify'] + name.split())

    def complete(self):
        ids = self.input_taskids()
        run_task([ids, 'done'])

    def custom_command(self):
        command = self.input_sequence('Enter your command')
        run_task(command.split())

    def manage_wifi(self, timer_running=False, timer_state=State.WORK):
        if self.password is None:
            self.password = self.input_sequence('Messing with wifi. Enter your'
                                                ' password').decode('utf-8')

        if timer_running and timer_state is not State.WORK:
            child = spawn('sudo systemctl start netctl-auto@wlp2s0')
        else:
            child = spawn('sudo systemctl stop netctl-auto@wlp2s0')

        child.expect('.*')
        child.sendline(self.password)
        child.expect(EOF)


def main(stdscr):
    sync()
    windrawer = WinDrawer(stdscr)
    with PomodoroTimer() as pomodoro_timer:
        # (func, args)
        task_actions = {
            "KEY_RESIZE": (windrawer.draw_windows,),
            'r': (windrawer.refresh_tasks,),
            'a': (windrawer.add,),
            'd': (windrawer.delete,),
            'c': (windrawer.complete,),
            'm': (windrawer.modify,),
            '!': (windrawer.custom_command,),
            'p': (toggle_timer, windrawer, pomodoro_timer),
            's': (pomodoro_timer.reset,),
            'n': (next_phase, windrawer, pomodoro_timer),
            'y': (sync, windrawer.write_status),
            'q': (app_quit, windrawer),
        }

        while True:
            try:
                windrawer.write_status('(r)efresh tasks, (a)dd task, (d)elete '
                                       'task, (c)omplete task, (m)odify,'
                                       '(!)custom command, (p)omodoro (toggle)'
                                       ', (s)top pomodoro, (n)ext pomodoro '
                                       'phase, s(y)nc server, (q)uit')

                read_char = windrawer.input_char()

                try:
                    action, *params = task_actions[read_char]
                    action(*params)
                    windrawer.refresh_tasks()
                except KeyboardInterrupt:
                    continue
                except KeyError:
                    windrawer.write_status(f'Unknown action: "{read_char}". '
                                           'Press any key to continue')
                    windrawer.input_char()

            except KeyboardInterrupt:
                app_quit(windrawer)


def app_quit(windrawer):
    sync(windrawer.write_status)
    windrawer.manage_wifi()
    quit()


try:
    wrapper(main)
except error:
    print(f'An error occured while drawing {argv[0]}. My best guess is that '
          f'the window was too small')
