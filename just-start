#!/usr/bin/env/python

from contextlib import contextmanager
from curses import wrapper, echo, noecho, cbreak, nocbreak, newwin, error
from curses.textpad import rectangle
from math import floor
from subprocess import run, PIPE
from sys import argv


def input_char(textbox_window):
    textbox_window.clear()
    return textbox_window.getkey(*textbox_window.getyx())


def input_sequence(textbox_window, status_window, status):
    write_status(status_window, status + " and press Ctrl-Enter when done (or "
                 "Ctrl-C to cancel)")
    textbox_window.clear()
    echo()
    nocbreak()

    try:
        key_sequence = textbox_window.getstr(*textbox_window.getyx())
    finally:
        noecho()
        cbreak()
    return key_sequence


def toggle_pomodoro():
    pass


def stop():
    pass


def complete(task_window, textbox_window, status_window):
    id_ = input_taskid(textbox_window, status_window)
    run(['task', id_, 'done'], stdout=PIPE)


def input_taskid(textbox_window, status_window):
    id_ = input_sequence(textbox_window, status_window,
                            "Enter the task's id")

    while True:
        try:
            int(id_)
            return id_
        except ValueError:
            id_ = input_sequence(textbox_window, status_window,
                                    "Please enter a valid id")


def run_task(arg_list=[]):
    return run(['task'] + arg_list, stdout=PIPE)


def add(task_window, textbox_window, status_window):
    name = input_sequence(textbox_window, status_window,
                          "Enter the new task's data")
    run_task(['add'] + name.split())


def delete(task_window, textbox_window, status_window):
    id_ = input_taskid(textbox_window, status_window)
    run_task([id_, 'delete', 'rc.confirmation=off'])


def modify(task_window, textbox_window, status_window):
    id_ = input_taskid(textbox_window, status_window)
    name = input_sequence(textbox_window, status_window,
                          "Enter the modified task's data")
    run_task([id_, 'modify'] + name.split())


def custom_command(task_window, textbox_window, status_window):
    command = input_sequence(textbox_window, status_window, 'Enter your command')

    run_task(command.split())


def refresh_tasks(task_window):
    task_window.clear()
    tasks = run_task().stdout.decode('utf-8').split("\n")

    try:
        for y, task in enumerate(tasks):
            task_window.addstr(y, 1, task)
    except error:
        pass

    task_window.refresh()


def write_status(status_window, status):
    status_window.clear()
    status_window.addstr(status)
    status_window.refresh()


def newborderedwin(height, width, start_y, start_x):
    borderedwindow = newwin(height, width, start_y, start_x)
    borderedwindow.clear()
    borderedwindow.border()
    borderedwindow.refresh()

    return newwin(height - 2, width - 2, start_y + 1, start_x + 1)


class WinDrawer():
    def __init__(self, stdscr):
        self.stdscr = stdscr


    def draw_windows(self, stdscr):
        stdscr.refresh()

        MAX_Y, MAX_X = stdscr.getmaxyx()
        STATUS_WINDOW_HEIGHT = 5
        TEXTBOX_WINDOW_HEIGHT = 4
        TASK_WINDOW_HEIGHT = MAX_Y - STATUS_WINDOW_HEIGHT - TEXTBOX_WINDOW_HEIGHT

        self.task_window = newborderedwin(TASK_WINDOW_HEIGHT, MAX_X - 1,
                                     0, 0)
        self.status_window = newborderedwin(STATUS_WINDOW_HEIGHT, MAX_X - 1,
                                       TASK_WINDOW_HEIGHT, 0)
        self.textbox_window = newborderedwin(TEXTBOX_WINDOW_HEIGHT, MAX_X - 1,
                                        TASK_WINDOW_HEIGHT + STATUS_WINDOW_HEIGHT, 0)

        refresh_tasks(self.task_window)
        return self.task_window, self.status_window, self.textbox_window


def main(stdscr):
    windrawer = WinDrawer(stdscr)
    task_window, status_window, textbox_window = windrawer.draw_windows(stdscr)

    task_actions = {
        'r': refresh_tasks,
    }
    io_actions = {
        'a': add,
        'd': delete,
        'c': complete,
        'm': modify,
        '!': custom_command,
    }
    stdscr_actions = {
        "KEY_RESIZE": windrawer.draw_windows,
    }
    parameterless_actions = {
        'p': toggle_pomodoro,
        's': stop,
        'q': quit,
    }

    while True:
        try:
            write_status(status_window, '(r)efresh tasks, (a)dd task, (d)elete '
                         'task, (c)omplete task, (m)odify, (!)custom command,'
                         ' (p)omodoro (toggle), (s)top pomodoro, (q)uit')
            read_char = input_char(textbox_window)

            try:
                task_actions[read_char](task_window)
                continue
            except KeyError:
                pass

            try:
                action = io_actions[read_char]
                action(task_window, textbox_window, status_window)
                refresh_tasks(task_window)
                continue
            except KeyboardInterrupt:
                continue
            except KeyError:
                pass

            try:
                new_windows = stdscr_actions[read_char](stdscr)
                task_window, status_window, textbox_window = new_windows
                continue
            except KeyError:
                pass

            try:
                parameterless_actions[read_char]()
            except KeyError:
                write_status(status_window, f'Unknown action: "{read_char}". '
                             'Press any key to continue')
                input_char(textbox_window)

        except KeyboardInterrupt:
            quit()


try:
    wrapper(main)
except error:
    print(f"An error occured while drawing {argv[0]}. My best guess is that the "
          f"window was too small")
