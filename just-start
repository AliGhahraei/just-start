#!/usr/bin/env/python

from contextlib import contextmanager
from curses import wrapper, echo, noecho, cbreak, nocbreak, newwin, error
from curses.textpad import rectangle
from math import floor
from subprocess import run, PIPE
from sys import argv


def toggle_pomodoro():
    pass


def stop():
    pass


def run_task(arg_list=[]):
    return run(['task'] + arg_list, stdout=PIPE)


def newborderedwin(height, width, start_y, start_x):
    borderedwindow = newwin(height, width, start_y, start_x)
    borderedwindow.clear()
    borderedwindow.border()
    borderedwindow.refresh()

    return newwin(height - 2, width - 2, start_y + 1, start_x + 1)


class WinDrawer():
    def __init__(self, stdscr):
        self.stdscr = stdscr


    def input_char(self):
        self.textbox_window.clear()
        return self.textbox_window.getkey(*self.textbox_window.getyx())


    def write_status(self, status):
        self.status_window.clear()
        self.status_window.addstr(status)
        self.status_window.refresh()


    def input_sequence(self, status):
        self.write_status(status + " and press Ctrl-Enter when done (or "
                     "Ctrl-C to cancel)")
        self.textbox_window.clear()
        echo()
        nocbreak()

        try:
            key_sequence = self.textbox_window.getstr(
                *self.textbox_window.getyx())
        finally:
            noecho()
            cbreak()
        return key_sequence


    def input_taskid(self):
        id_ = self.input_sequence("Enter the task's id")

        while True:
            try:
                int(id_)
                return id_
            except ValueError:
                id_ = self.input_sequence("Please enter a valid id")


    def draw_windows(self, stdscr):
        stdscr.refresh()

        MAX_Y, MAX_X = stdscr.getmaxyx()
        STATUS_WINDOW_HEIGHT = 5
        TEXTBOX_WINDOW_HEIGHT = 4
        TASK_WINDOW_HEIGHT = MAX_Y - STATUS_WINDOW_HEIGHT - TEXTBOX_WINDOW_HEIGHT

        self.task_window = newborderedwin(TASK_WINDOW_HEIGHT, MAX_X - 1,
                                          0, 0)
        self.status_window = newborderedwin(STATUS_WINDOW_HEIGHT, MAX_X - 1,
                                            TASK_WINDOW_HEIGHT, 0)
        self.textbox_window = newborderedwin(TEXTBOX_WINDOW_HEIGHT, MAX_X - 1,
                                             TASK_WINDOW_HEIGHT
                                             + STATUS_WINDOW_HEIGHT, 0)

        self.refresh_tasks()
        return self.task_window, self.status_window, self.textbox_window


    def refresh_tasks(self):
        self.task_window.clear()
        tasks = run_task().stdout.decode('utf-8').split("\n")

        try:
            for y, task in enumerate(tasks):
                self.task_window.addstr(y, 1, task)
        except error:
            pass

        self.task_window.refresh()


    def add(self):
        name = self.input_sequence("Enter the new task's data")
        run_task(['add'] + name.split())


    def delete(self):
        id_ = self.input_taskid()
        run_task([id_, 'delete', 'rc.confirmation=off'])


    def modify(self):
        id_ = self.input_taskid()
        name = self.input_sequence("Enter the modified task's data")
        run_task([id_, 'modify'] + name.split())


    def complete(self):
        id_ = self.input_taskid()
        run(['task', id_, 'done'], stdout=PIPE)


    def custom_command(self):
        command = self.input_sequence('Enter your command')
        run_task(command.split())


def main(stdscr):
    windrawer = WinDrawer(stdscr)
    windrawer.draw_windows(stdscr)

    task_actions = {
        "KEY_RESIZE": windrawer.draw_windows,
        'r': windrawer.refresh_tasks,
        'a': windrawer.add,
        'd': windrawer.delete,
        'c': windrawer.complete,
        'm': windrawer.modify,
        '!': windrawer.custom_command,
        'p': toggle_pomodoro,
        's': stop,
        'q': quit,
    }

    while True:
        try:
            windrawer.write_status('(r)efresh tasks, (a)dd task, (d)elete '
                         'task, (c)omplete task, (m)odify, (!)custom command,'
                         ' (p)omodoro (toggle), (s)top pomodoro, (q)uit')

            read_char = windrawer.input_char()

            try:
                task_actions[read_char]()
                windrawer.refresh_tasks()
            except KeyboardInterrupt:
                continue
            except KeyError:
                windrawer.write_status(f'Unknown action: "{read_char}". '
                                       'Press any key to continue')
                windrawer.input_char()

        except KeyboardInterrupt:
            quit()


try:
    wrapper(main)
except error:
    print(f"An error occured while drawing {argv[0]}. My best guess is that the "
          f"window was too small")
