#!/usr/bin/env python3

from curses import (wrapper, echo, noecho, cbreak, nocbreak, newwin, error,
                    color_pair, init_pair, COLOR_RED, COLOR_WHITE, COLOR_GREEN,
                    use_default_colors)
from os.path import expanduser
from pexpect import spawn, EOF
from platform import system
from subprocess import run, PIPE, STDOUT
from sys import argv

from yaml import safe_load

from pomodoro import PomodoroTimer


SYNC_MSG = 'Syncing task server...'

CONFIG_LOCATION = '~/.config/just-start/preferences.yml'

HELP_MESSAGE = ('(a)dd task, (c)omplete task, (d)elete task, (h)elp, s(k)ip to'
                ' another pomodoro phase, (m)odify task, (p)omodoro pause/'
                'resume, (q)uit, (r)efresh tasks, (s)top pomodoro, s(y)nc'
                ' server, (!) custom command')


def run_task(arg_list=None):
    arg_list = arg_list or None
    task_output = run(['task'] + arg_list, stdout=PIPE, stderr=STDOUT)
    return task_output.stdout.decode('utf-8')


def newborderedwin(height, width, start_y, start_x, title=''):
    borderedwindow = newwin(height, width, start_y, start_x)
    borderedwindow.clear()
    borderedwindow.border()
    borderedwindow.move(0, 2)
    borderedwindow.addstr(title)
    borderedwindow.refresh()

    return newwin(height - 2, width - 2, start_y + 1, start_x + 1)


def toggle_timer(windrawer, timer):
    timer.toggle()
    windrawer.manage_wifi(timer.is_running)


def stop_timer(windrawer, timer):
    timer.reset()
    windrawer.manage_wifi(timer_running=False)


def skip_phases(windrawer, timer):
    prompt = 'Enter how many phases you want to skip'
    valid_phases = False

    while not valid_phases:
        try:
            phases = int(windrawer.input_sequence(prompt))
        except ValueError:
            pass
        else:
            if phases >= 1 and timer.advance_phases(phases_skipped=phases):
                valid_phases = True
                windrawer.manage_wifi(timer_running=True)

        prompt = 'Please enter a valid number of phases'


def parse_config():
    with open(expanduser(CONFIG_LOCATION)) as f:
        return safe_load(f)


class WinDrawer:
    def __init__(self, stdscr, config):
        self.stdscr = stdscr
        self.password = config['password']
        self.written_status = ''
        self.status_color = COLOR_WHITE
        self.written_pomodoro_status = ''
        self.written_prompt = ''

        blocking_lines = '\\n'.join(
            [f'127.0.0.1\\t{blocked_site}\\t#juststart\\n'
             f'127.0.0.1\\twww.{blocked_site}\\t#juststart'
             for blocked_site in config['blocked_sites']])

        self.block_command = (f'/bin/bash -c "echo -e \'{blocking_lines}\' | '
                              f'sudo tee -a /etc/hosts > /dev/null"')

        self.unblock_command = 'sudo sed -i -e /#juststart$/d /etc/hosts'

        self.fetch_tasks()
        self.draw_windows()

        use_default_colors()
        for color in COLOR_WHITE, COLOR_GREEN, COLOR_RED:
            init_pair(color, color, -1)

    def sync(self):
        try:
            self.write_status(SYNC_MSG)
            self.write_status(run_task(['sync']))
        except KeyboardInterrupt:
            pass

    def input_char(self):
        self.textbox_window.clear()
        return self.textbox_window.getkey(*self.textbox_window.getyx())

    def write_status(self, status, color=COLOR_GREEN):
        self.status_window.clear()
        self.status_window.addstr(status, color_pair(color))
        self.status_window.refresh()
        self.written_status = status
        self.status_color = color

    def write_pomodoro_status(self, status):
        self.pomodoro_window.clear()
        self.pomodoro_window.addstr(status)
        self.pomodoro_window.refresh()
        self.written_pomodoro_status = status

    def write_prompt(self, prompt):
        self.prompt_window.clear()
        self.prompt_window.addstr(prompt)
        self.prompt_window.refresh()
        self.written_prompt = prompt

    def input_sequence(self, status):
        self.write_prompt(status + " and press Ctrl-Enter when done (or "
                          "Ctrl-C to cancel)")
        self.textbox_window.clear()
        echo()
        nocbreak()

        try:
            key_sequence = self.textbox_window.getstr(
                *self.textbox_window.getyx())
        finally:
            noecho()
            cbreak()
        return key_sequence

    def input_taskids(self):
        ids = self.input_sequence("Enter the task's ids")

        while True:
            try:
                list(map(int, ids))
                return ids
            except ValueError:
                ids = self.input_sequence("Please enter valid ids")

    def write_tasks(self):
        self.task_window.clear()

        try:
            for y, task in enumerate(self.tasks):
                self.task_window.addstr(y, 1, task)
        except error:
            pass

        self.task_window.refresh()

    def draw_windows(self):
        self.stdscr.refresh()

        MAX_Y, MAX_X = self.stdscr.getmaxyx()
        STATUS_WINDOW_HEIGHT = 7
        POMODORO_WINDOW_HEIGHT = 7
        PROMPT_WINDOW_HEIGHT = 3
        TEXTBOX_WINDOW_HEIGHT = 3
        TASK_WINDOW_HEIGHT = (MAX_Y
                              - STATUS_WINDOW_HEIGHT
                              - PROMPT_WINDOW_HEIGHT
                              - TEXTBOX_WINDOW_HEIGHT)

        self.task_window = newborderedwin(TASK_WINDOW_HEIGHT, MAX_X - 1,
                                          0, 0)
        self.pomodoro_window = newborderedwin(POMODORO_WINDOW_HEIGHT,
                                              int(MAX_X / 2),
                                              TASK_WINDOW_HEIGHT,
                                              int(MAX_X / 2),
                                              'Pomodoro status')
        self.status_window = newborderedwin(STATUS_WINDOW_HEIGHT,
                                            int(MAX_X / 2),
                                            TASK_WINDOW_HEIGHT,
                                            0,
                                            'App status')

        prompt_y = TASK_WINDOW_HEIGHT + STATUS_WINDOW_HEIGHT + 1
        self.prompt_window = newwin(PROMPT_WINDOW_HEIGHT - 2, MAX_X - 3,
                                    prompt_y, 1)

        textbox_y = (TASK_WINDOW_HEIGHT + STATUS_WINDOW_HEIGHT
                     + PROMPT_WINDOW_HEIGHT)
        self.textbox_window = newwin(TEXTBOX_WINDOW_HEIGHT - 2, MAX_X - 3,
                                     textbox_y, 1)

        newborderedwin(PROMPT_WINDOW_HEIGHT + TEXTBOX_WINDOW_HEIGHT, MAX_X - 1,
                       TASK_WINDOW_HEIGHT + STATUS_WINDOW_HEIGHT, 0)

        self.write_pomodoro_status(self.written_pomodoro_status)
        self.write_status(self.written_status, color=self.status_color)
        self.write_prompt(self.written_prompt)

        self.write_tasks()

    def fetch_tasks(self):
        self.tasks = run_task().split("\n")

    def refresh_tasks(self):
        self.fetch_tasks()
        self.write_tasks()

    def add(self):
        name = self.input_sequence("Enter the new task's data")
        self.write_status(run_task(['add'] + name.split()))

    def delete(self):
        ids = self.input_taskids()
        self.write_status(run_task([ids, 'delete', 'rc.confirmation=off']))

    def modify(self):
        ids = self.input_taskids()
        name = self.input_sequence("Enter the modified task's data")
        self.write_status(run_task([ids, 'modify'] + name.split()))

    def complete(self):
        ids = self.input_taskids()
        self.write_status(run_task([ids, 'done']))

    def custom_command(self):
        command = self.input_sequence('Enter your command')
        self.write_status(run_task(command.split()))

    def run_sudo(self, command):
        child = spawn(command)

        try:
            child.sendline(self.password)
            child.expect(EOF)
        except OSError:
            pass

    def manage_blocked_sites(self, blocked):
        if blocked:
            self.run_sudo(self.unblock_command)
            self.run_sudo(self.block_command)
        else:
            self.run_sudo(self.unblock_command)

    def manage_wifi(self, timer_running=False):
        if timer_running:
            if system() == 'Linux':
                self.run_sudo('sudo systemctl start netctl-auto@wlp2s0')
            else:
                self.run_sudo('networksetup -setairportpower en0 on')
        else:
            if system() == 'Linux':
                self.run_sudo('sudo systemctl stop netctl-auto@wlp2s0')
            else:
                self.run_sudo('networksetup -setairportpower en0 off')


def main(stdscr):
    config = parse_config()
    windrawer = WinDrawer(stdscr, config)
    windrawer.sync()
    with PomodoroTimer(windrawer.write_pomodoro_status,
                       windrawer.manage_blocked_sites,
                       config, CONFIG_LOCATION) as pomodoro_timer:

        refreshing_actions = {
            'a': windrawer.add,
            'c': windrawer.complete,
            'd': windrawer.delete,
            'm': windrawer.modify,
            'y': windrawer.sync,
            '!': windrawer.custom_command,
        }
        non_refreshing_actions = {
            "KEY_RESIZE": (windrawer.draw_windows,),
            'h': (windrawer.write_status, HELP_MESSAGE),
            'k': (skip_phases, windrawer, pomodoro_timer),
            'p': (toggle_timer, windrawer, pomodoro_timer),
            'q': (app_quit, windrawer),
            'r': (windrawer.refresh_tasks,),
            's': (stop_timer, windrawer, pomodoro_timer),
        }

        quit_requested = False
        while not quit_requested:
            windrawer.write_prompt('Waiting for user. Pressing h shows'
                                   ' available actions')

            try:
                read_char = windrawer.input_char()

                try:
                    try:
                        refreshing_actions[read_char]()
                    except KeyError:
                        action, *params = non_refreshing_actions[read_char]
                        action(*params)
                    else:
                        windrawer.refresh_tasks()

                except KeyboardInterrupt:
                    continue
                except KeyError:
                    windrawer.write_status(f'Unknown key: "{read_char}"',
                                           color=COLOR_RED)

            except KeyboardInterrupt:
                quit_requested = True

        app_quit(windrawer)


def app_quit(windrawer):
    windrawer.sync()
    windrawer.manage_wifi()
    quit()


if __name__ == '__main__':
    try:
        wrapper(main)
    except error:
        print(f'An error occured while drawing {argv[0]}. My best guess is'
              f' that the window was too small')
