#!/usr/bin/env python3

from curses import (wrapper, echo, noecho, cbreak, nocbreak, newwin, error,
                    color_pair, init_pair, COLOR_RED, COLOR_WHITE, COLOR_GREEN,
                    use_default_colors)
from functools import partial
from logging import error as log_error, basicConfig as loggingConfig
from os import getenv, makedirs
from os.path import expanduser, join
from pexpect import spawn, EOF
from platform import system
from signal import signal, SIGTERM
from subprocess import run, PIPE, STDOUT
from sys import argv
from time import sleep

from yaml import safe_load

from pomodoro import PomodoroTimer, PomodoroError


SYNC_MSG = 'Syncing task server...'

CONFIG_DIR = join(getenv('XDG_CONFIG_HOME', expanduser(join('~', '.config'))),
                  'just-start')
LOCAL_DIR = join(getenv('XDG_DATA_HOME',
                        expanduser(join('~', '.local', 'share'))),
                 'just-start')

CONFIG_PATH = join(CONFIG_DIR, 'preferences.yml')
LOG_PATH = join(LOCAL_DIR, 'log')


HELP_MESSAGE = ('(a)dd task, (c)omplete task, (d)elete task, (h)elp, s(k)ip to'
                ' another pomodoro phase, (l)ocation change, (m)odify task,'
                ' (p)omodoro pause/resume, (q)uit, (r)efresh tasks, (s)top'
                ' pomodoro, s(y)nc server, (!) custom command')


class JustStartError(Exception):
    pass


class TaskWarriorError(JustStartError):
    pass


class ConfigurationMissingError(JustStartError, FileNotFoundError):
    pass


class ActionError(JustStartError):
    pass


def run_task(arg_list=None):
    arg_list = arg_list or []
    completed_process = run(['task'] + arg_list, stdout=PIPE, stderr=STDOUT)
    process_output = completed_process.stdout.decode('utf-8')

    if completed_process.returncode != 0:
        raise TaskWarriorError(process_output)

    return process_output


def newborderedwin(height, width, start_y, start_x, title=''):
    borderedwindow = newwin(height, width, start_y, start_x)
    borderedwindow.clear()
    borderedwindow.border()
    borderedwindow.move(0, 2)
    borderedwindow.addstr(title)
    borderedwindow.refresh()

    return newwin(height - 2, width - 2, start_y + 1, start_x + 1)


def toggle_timer(network_handler, timer):
    timer.toggle()
    network_handler.manage_wifi(timer.is_running)


def reset_timer(network_handler, timer, at_work_user_overridden=None):
    timer.reset(at_work_user_overridden=at_work_user_overridden)
    network_handler.manage_wifi(timer_running=False)


def skip_phases(prompt_handler, network_handler, timer):
    prompt = 'Enter how many phases you want to skip'
    valid_phases = False

    while not valid_phases:
        try:
            phases = int(prompt_handler.prompt_string(prompt))
        except ValueError:
            pass
        else:
            if phases >= 1:
                timer.advance_phases(phases_skipped=phases)
                valid_phases = True
                network_handler.manage_wifi(timer_running=True)

        prompt = 'Please enter a valid number of phases'


def location_change(prompt_handler, network_handler, timer):
    location = prompt_handler.prompt_string("Enter 'w' for work or anything"
                                            " else for home")
    at_work = location == 'w'
    reset_timer(network_handler, timer, at_work)
    toggle_timer(network_handler, timer)


def parse_config():
    try:
        with open(CONFIG_PATH) as f:
            return safe_load(f)
    except FileNotFoundError:
        raise ConfigurationMissingError(
            f"No config file at '{CONFIG_PATH}'. Check if it's really there"
            f" (and its permissions) or create one if it's the first time you"
            f" use this app")


class WindowHandler:
    def __init__(self, stdscr):
        self.stdscr = stdscr

        use_default_colors()
        for color in COLOR_WHITE, COLOR_GREEN, COLOR_RED:
            init_pair(color, color, -1)

        self.task_window = None
        self.tasks = ''

        self.pomodoro_window = None
        self.written_pomodoro_status = ''

        self.status_window = None
        self.written_status = ''
        self.status_color = COLOR_WHITE

        self.prompt_handler = PromptHandler(self.stdscr)

        self.draw_windows()

    def draw_windows(self):
        self.stdscr.refresh()

        max_y, max_x = self.stdscr.getmaxyx()
        pomodoro_window_height = 5
        task_window_height = max_y - pomodoro_window_height
        task_window_width = int(max_x / 2)

        self.task_window = newborderedwin(task_window_height,
                                          task_window_width, 0, 0)
        self.refresh_tasks()

        self.status_window = newborderedwin(task_window_height,
                                            task_window_width,
                                            0,
                                            task_window_width,
                                            'App status')

        prompt_y = task_window_height
        self.prompt_handler.draw_prompt_windows(prompt_y,
                                                pomodoro_window_height,
                                                task_window_width,
                                                self.status_window,
                                                self.write_status)

        self.pomodoro_window = newborderedwin(pomodoro_window_height,
                                              task_window_width,
                                              task_window_height,
                                              task_window_width,
                                              'Pomodoro status')

        self.write_pomodoro_status(self.written_pomodoro_status)
        self.write_status(self.written_status, color=self.status_color)

    def write_status(self, status, color=COLOR_WHITE):
        self.prompt_handler.write_prompt('')
        self.status_window.clear()
        self.status_window.addstr(status, color_pair(color))
        self.status_window.refresh()
        self.written_status = status
        self.status_color = color

    def write_pomodoro_status(self, status):
        self.status_window.clear()
        self.pomodoro_window.clear()
        self.pomodoro_window.addstr(status)
        self.pomodoro_window.refresh()
        self.written_pomodoro_status = status

    def sync(self):
        self.write_status(SYNC_MSG)

        try:
            self.write_status(run_task(['sync']))
        except TaskWarriorError as exc:
            self.write_status(str(exc), color=COLOR_RED)
        except KeyboardInterrupt:
            pass

    def refresh_tasks(self):
        self.tasks = run_task().split("\n")
        self.task_window.clear()

        try:
            for y, task in enumerate(self.tasks):
                self.task_window.addstr(y, 1, task)
        except error:
            pass

        self.task_window.refresh()


class PromptHandler:
    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.written_prompt = ''
        self.prompt_color = COLOR_WHITE

        self.status_window = self.write_status = self.prompt_window = None
        self.input_window = None

    def draw_prompt_windows(self, prompt_y, prompt_height, prompt_width,
                            status_window, write_status):
        newborderedwin(prompt_height, prompt_width, prompt_y, 0)

        self.prompt_window = newwin(1, prompt_width - 2,
                                    prompt_y + 1, 1)

        self.input_window = newwin(prompt_height - 3,  prompt_width - 2,
                                   prompt_y + 2, 1)

        self.status_window = status_window
        self.write_status = write_status

        self.input_window.refresh()
        self.prompt_window.refresh()

    def write_prompt(self, prompt, color=COLOR_WHITE):
        self.status_window.clear()
        self.prompt_window.clear()
        self.prompt_window.addstr(prompt, color_pair(color))
        self.prompt_window.refresh()
        self.written_prompt = prompt

    def prompt_char(self, status, color=COLOR_WHITE):
        self.write_prompt(status, color=color)
        self.input_window.clear()
        return self.input_window.getkey(
            *self.input_window.getyx()
        )

    def prompt_string(self, status, color=COLOR_WHITE):
        self.write_prompt(status + " and press Ctrl-Enter when done (or "
                          "Ctrl-C to cancel)", color=color)
        self.input_window.clear()

        try:
            echo()
            nocbreak()
            key_sequence = self.input_window.getstr(
                *self.input_window.getyx())
        finally:
            noecho()
            cbreak()
        return key_sequence.decode('utf-8')

    def input_taskids(self):
        ids = self.prompt_string("Enter the task's ids")

        while True:
            splitted_ids = ids.split(',')
            try:
                list(map(int, splitted_ids))
            except ValueError:
                ids = self.prompt_string("Please enter valid ids",
                                         color=COLOR_RED)
            else:
                return ids

    def add(self):
        name = self.prompt_string("Enter the new task's data")
        self.write_status(run_task(['add'] + name.split()))

    def delete(self):
        ids = self.input_taskids()
        self.write_status(run_task([ids, 'delete', 'rc.confirmation=off']))

    def modify(self):
        ids = self.input_taskids()
        name = self.prompt_string("Enter the modified task's data")
        self.write_status(run_task([ids, 'modify'] + name.split()))

    def complete(self):
        ids = self.input_taskids()
        self.write_status(run_task([ids, 'done']))

    def custom_command(self):
        command = self.prompt_string('Enter your command')
        self.write_status(run_task(command.split()))


class NetworkHandler:
    def __init__(self, config):
        self.password = config['password']

        blocking_lines = '\\n'.join(
            [f'127.0.0.1\\t{blocked_site}\\t#juststart\\n'
             f'127.0.0.1\\twww.{blocked_site}\\t#juststart'
             for blocked_site in config['blocked_sites']])

        self.block_command = (f'/bin/bash -c "echo -e \'{blocking_lines}\' | '
                              f'sudo tee -a /etc/hosts > /dev/null"')
        self.unblock_command = 'sudo sed -i -e /#juststart$/d /etc/hosts'

    def run_sudo(self, command):
        child = spawn(command)

        try:
            child.sendline(self.password)
            child.expect(EOF)
        except OSError:
            pass

    def manage_blocked_sites(self, blocked):
        if blocked:
            self.run_sudo(self.unblock_command)
            self.run_sudo(self.block_command)
        else:
            self.run_sudo(self.unblock_command)

    def manage_wifi(self, timer_running=False):
        if timer_running:
            if system() == 'Linux':
                self.run_sudo('sudo systemctl start netctl-auto@wlp2s0')
            else:
                self.run_sudo('networksetup -setairportpower en0 on')
        else:
            if system() == 'Linux':
                self.run_sudo('sudo systemctl stop netctl-auto@wlp2s0')
            else:
                self.run_sudo('networksetup -setairportpower en0 off')


def main(stdscr):
    stdscr.clear()

    config = parse_config()
    window_handler = WindowHandler(stdscr)
    prompt_handler = window_handler.prompt_handler
    network_handler = NetworkHandler(config)

    signal(SIGTERM, partial(handler, window_handler, network_handler))

    window_handler.sync()

    refreshing_actions = {
        'a': prompt_handler.add,
        'c': prompt_handler.complete,
        'd': prompt_handler.delete,
        'm': prompt_handler.modify,
        'y': window_handler.sync,
        '!': prompt_handler.custom_command,
    }

    with PomodoroTimer(window_handler.write_pomodoro_status,
                       network_handler.manage_blocked_sites, config,
                       CONFIG_PATH) as pomodoro_timer:
        non_refreshing_actions = {
            "KEY_RESIZE": (window_handler.draw_windows,),
            'h': (window_handler.write_status, HELP_MESSAGE),
            'k': (skip_phases, prompt_handler, network_handler, pomodoro_timer),
            'l': (location_change, prompt_handler, network_handler,
                  pomodoro_timer),
            'p': (toggle_timer, network_handler, pomodoro_timer),
            'q': (quit_gracefully, window_handler, network_handler),
            'r': (window_handler.refresh_tasks,),
            's': (reset_timer, network_handler, pomodoro_timer),
        }

        while True:
            try:
                execute_user_action(prompt_handler, window_handler,
                                    refreshing_actions, non_refreshing_actions)
            except (JustStartError, PomodoroError) as exc:
                window_handler.write_status(str(exc), color=COLOR_RED)


def execute_user_action(prompt_handler, window_handler, refreshing_actions,
                        non_refreshing_actions):
    try:
        read_char = prompt_handler.prompt_char('Waiting for user.'
                                               ' Pressing h shows'
                                               ' available actions')
        window_handler.write_status('')
        sleep(0.1)
    except KeyboardInterrupt:
        raise ActionError(f'No action was selected yet, but Ctrl+C was pressed'
                          f'. Use q to quit')

    try:
        refreshing_actions[read_char]()
    except KeyError:
        try:
            action, *params = non_refreshing_actions[read_char]
            action(*params)
        except KeyError:
            raise ActionError(f'Unknown key action: "{read_char}"')
        except KeyboardInterrupt:
            # Cancel current action
            pass
    except KeyboardInterrupt:
        # Cancel current action
        pass
    else:
        window_handler.refresh_tasks()


def handler(window_handler, network_handler, *_):
    quit_gracefully(window_handler, network_handler)


def quit_gracefully(window_handler, network_handler):
    window_handler.sync()
    network_handler.manage_wifi()
    quit()


def log(error_, message=''):
    print(message)
    log_error(f'{type(error_)}: {error_}')
    print(f'Log written to "{LOG_PATH}"')

    try:
        loggingConfig(filename=LOG_PATH)
    except FileNotFoundError:
        makedirs(LOCAL_DIR)
        loggingConfig(filename=LOG_PATH)

    try:
        wrapper(main)
    except ConfigurationMissingError as e:
        print(str(e))
    except error as e:
        log(e, f'An error occurred while drawing {argv[0]}. My best guess is'
               f' that the window was too small.')
    except Exception as e:
        log(e, f'Unhandled error.')
