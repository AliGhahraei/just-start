#!/usr/bin/env python3

from curses import wrapper, echo, noecho, cbreak, nocbreak, newwin, error
from os.path import expanduser
from pexpect import spawn, EOF
from platform import system
from subprocess import run, PIPE
from sys import argv

from yaml import safe_load

from pomodoro import PomodoroTimer


SYNC_MSG = 'Syncing task server...'


def run_task(arg_list=[]):
    return run(['task'] + arg_list, stdout=PIPE)


def newborderedwin(height, width, start_y, start_x):
    borderedwindow = newwin(height, width, start_y, start_x)
    borderedwindow.clear()
    borderedwindow.border()
    borderedwindow.refresh()

    return newwin(height - 2, width - 2, start_y + 1, start_x + 1)


def sync(display_function=print):
    try:
        display_function(SYNC_MSG)
        run_task(['sync'])
    except KeyboardInterrupt:
        pass


def toggle_timer(windrawer, timer):
    timer.toggle()
    windrawer.manage_wifi(timer.is_running)


def stop_timer(windrawer, timer):
    timer.reset()
    windrawer.manage_wifi(timer_running=False)


def next_phase(windrawer, timer):
    timer.next_phase()
    windrawer.manage_wifi(timer_running=True)


def parse_config():
    with open(expanduser('~/.config/just-start/preferences.yml')) as f:
        return safe_load(f)


class WinDrawer():
    def __init__(self, stdscr, config):
        self.stdscr = stdscr
        self.password = config['password']

        blocking_lines = '\\n'.join(
            [f'127.0.0.1\\t{blocked_site}\\t#juststart\\n'
             f'127.0.0.1\\twww.{blocked_site}\\t#juststart'
             for blocked_site in config['blocked_sites']])

        self.block_command = (f'/bin/bash -c "echo -e \'{blocking_lines}\' | '
                              f'sudo tee -a /etc/hosts > /dev/null"')

        self.unblock_command = 'sudo sed -i -e /#juststart$/d /etc/hosts'

        self.fetch_tasks()
        self.draw_windows(None)

    def input_char(self):
        self.textbox_window.clear()
        return self.textbox_window.getkey(*self.textbox_window.getyx())

    def write_status(self, status):
        self.status_window.clear()
        self.status_window.addstr(status)
        self.status_window.refresh()

    def write_pomodoro_status(self, status):
        self.pomodoro_window.clear()
        self.pomodoro_window.addstr(status)
        self.pomodoro_window.refresh()

    def input_sequence(self, status):
        self.write_status(status + " and press Ctrl-Enter when done (or "
                          "Ctrl-C to cancel)")
        self.textbox_window.clear()
        echo()
        nocbreak()

        try:
            key_sequence = self.textbox_window.getstr(
                *self.textbox_window.getyx())
        finally:
            noecho()
            cbreak()
        return key_sequence

    def input_taskids(self):
        ids = self.input_sequence("Enter the task's ids")

        while True:
            try:
                list(map(int, ids))
                return ids
            except ValueError:
                ids = self.input_sequence("Please enter valid ids")

    def write_tasks(self):
        self.task_window.clear()

        try:
            for y, task in enumerate(self.tasks):
                self.task_window.addstr(y, 1, task)
        except error:
            pass

        self.task_window.refresh()

    def draw_windows(self, pomodoro_timer):
        self.stdscr.refresh()

        MAX_Y, MAX_X = self.stdscr.getmaxyx()
        STATUS_WINDOW_HEIGHT = 4
        TEXTBOX_WINDOW_HEIGHT = 4
        POMODORO_WINDOW_HEIGHT = 3
        TASK_WINDOW_HEIGHT = (MAX_Y
                              - STATUS_WINDOW_HEIGHT
                              - TEXTBOX_WINDOW_HEIGHT
                              - POMODORO_WINDOW_HEIGHT)

        self.task_window = newborderedwin(TASK_WINDOW_HEIGHT, MAX_X - 1,
                                          0, 0)
        self.pomodoro_window = newborderedwin(POMODORO_WINDOW_HEIGHT,
                                              MAX_X - 1,
                                              TASK_WINDOW_HEIGHT,
                                              0)
        self.status_window = newborderedwin(STATUS_WINDOW_HEIGHT, MAX_X - 1,
                                            TASK_WINDOW_HEIGHT
                                            + POMODORO_WINDOW_HEIGHT,
                                            0)
        self.textbox_window = newborderedwin(TEXTBOX_WINDOW_HEIGHT, MAX_X - 1,
                                             TASK_WINDOW_HEIGHT
                                             + STATUS_WINDOW_HEIGHT
                                             + POMODORO_WINDOW_HEIGHT,
                                             0)

        if pomodoro_timer is not None:
            self.write_pomodoro_status(pomodoro_timer.written_status)

        self.write_tasks()

    def fetch_tasks(self):
        self.tasks = run_task().stdout.decode('utf-8').split("\n")

    def refresh_tasks(self):
        self.fetch_tasks()
        self.write_tasks()

    def add(self):
        name = self.input_sequence("Enter the new task's data")
        run_task(['add'] + name.split())

    def delete(self):
        ids = self.input_taskids()
        run_task([ids, 'delete', 'rc.confirmation=off'])

    def modify(self):
        ids = self.input_taskids()
        name = self.input_sequence("Enter the modified task's data")
        run_task([ids, 'modify'] + name.split())

    def complete(self):
        ids = self.input_taskids()
        run_task([ids, 'done'])

    def custom_command(self):
        command = self.input_sequence('Enter your command')
        run_task(command.split())

    def run_sudo(self, command):
        child = spawn(command)

        try:
            child.sendline(self.password)
            child.expect(EOF)
        except OSError:
            pass

    def manage_blocked_sites(self, blocked):
        if blocked:
            self.run_sudo(self.unblock_command)
            self.run_sudo(self.block_command)
        else:
            self.run_sudo(self.unblock_command)

    def manage_wifi(self, timer_running=False):
        if timer_running:
            if system() == 'Linux':
                self.run_sudo('sudo systemctl start netctl-auto@wlp2s0')
            else:
                self.run_sudo('networksetup -setairportpower en0 on')
        else:
            if system() == 'Linux':
                self.run_sudo('sudo systemctl stop netctl-auto@wlp2s0')
            else:
                self.run_sudo('networksetup -setairportpower en0 off')

def main(stdscr):
    config = parse_config()
    sync()
    windrawer = WinDrawer(stdscr, config)
    with PomodoroTimer(windrawer.write_pomodoro_status, windrawer.manage_blocked_sites,
                       config) as pomodoro_timer:

        # (func, args)
        refreshing_actions = {
            'a': (windrawer.add,),
            'd': (windrawer.delete,),
            'c': (windrawer.complete,),
            'm': (windrawer.modify,),
            '!': (windrawer.custom_command,),
            'y': (sync, windrawer.write_status),
        }
        non_refreshing_actions = {
            "KEY_RESIZE": (windrawer.draw_windows, pomodoro_timer),
            'p': (toggle_timer, windrawer, pomodoro_timer),
            's': (stop_timer, windrawer, pomodoro_timer),
            'n': (next_phase, windrawer, pomodoro_timer),
            'r': (windrawer.refresh_tasks,),
            'q': (app_quit, windrawer),
        }

        quit_requested = False
        while not quit_requested:
            try:
                windrawer.write_status('(r)efresh tasks, (a)dd task, (d)elete '
                                       'task, (c)omplete task, (m)odify, '
                                       '(!)custom command, (p)omodoro (toggle)'
                                       ', (s)top pomodoro, (n)ext pomodoro '
                                       'phase, s(y)nc server, (q)uit')

                read_char = windrawer.input_char()

                try:
                    try:
                        action, *params = refreshing_actions[read_char]
                        action(*params)
                    except KeyError:
                        action, *params = non_refreshing_actions[read_char]
                        action(*params)
                    else:
                        windrawer.refresh_tasks()
                except KeyboardInterrupt:
                    continue
                except KeyError:
                    windrawer.write_status(f'Unknown action: "{read_char}". '
                                           'Press any key to continue')
                    windrawer.input_char()

            except KeyboardInterrupt:
                quit_requested = True

        app_quit(windrawer)


def app_quit(windrawer):
    sync(windrawer.write_status)
    windrawer.manage_wifi()
    quit()


if __name__ == '__main__':
    try:
        wrapper(main)
    except error:
        print(f'An error occured while drawing {argv[0]}. My best guess is'
              f' that the window was too small')
