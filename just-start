#!/usr/bin/env/python

from curses import wrapper, echo, noecho, cbreak, nocbreak, newwin, error
from datetime import datetime, timedelta
from pexpect import spawn, EOF
from subprocess import run, PIPE
from sys import argv

from pomodoro import PomodoroTimer, State


SYNC_MSG = 'Syncing task server...'


def run_task(arg_list=[]):
    return run(['task'] + arg_list, stdout=PIPE)


def newborderedwin(height, width, start_y, start_x):
    borderedwindow = newwin(height, width, start_y, start_x)
    borderedwindow.clear()
    borderedwindow.border()
    borderedwindow.refresh()

    return newwin(height - 2, width - 2, start_y + 1, start_x + 1)


def sync(display_function=print):
    try:
        display_function(SYNC_MSG)
        run_task(['sync'])
    except KeyboardInterrupt:
        pass


def calc_end_time(time_left):
    end_time = datetime.now() + timedelta(seconds=time_left)
    return end_time.strftime('%H:%M')


def toggle_timer(windrawer, timer):
    windrawer.manage_wifi(not timer.is_running)
    timer.toggle()
    windrawer.write_pomodoro_status((f'{timer.state.value[0]}. End time: '
                                     f'{calc_end_time(timer.time_left)}'
                                     if timer.is_running else 'Paused'))


def stop_timer(windrawer, timer):
    timer.reset()
    windrawer.write_pomodoro_status('Pomodoro timer stopped')


def next_phase(windrawer, timer):
    windrawer.manage_wifi(timer_running=True)
    timer.next_phase()
    windrawer.write_pomodoro_status(f'{timer.state.value[0]}. End time: '
                                    f'{calc_end_time(timer.time_left)}')


class WinDrawer():
    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.password = None
        self.draw_windows()
        self.write_pomodoro_status('Pomodoro timer stopped')

    def input_char(self):
        self.textbox_window.clear()
        return self.textbox_window.getkey(*self.textbox_window.getyx())

    def write_status(self, status):
        self.status_window.clear()
        self.status_window.addstr(status)
        self.status_window.refresh()

    def write_pomodoro_status(self, status):
        self.pomodoro_window.clear()
        self.pomodoro_window.addstr(status)
        self.pomodoro_window.refresh()

    def input_sequence(self, status):
        self.write_status(status + " and press Ctrl-Enter when done (or "
                          "Ctrl-C to cancel)")
        self.textbox_window.clear()
        echo()
        nocbreak()

        try:
            key_sequence = self.textbox_window.getstr(
                *self.textbox_window.getyx())
        finally:
            noecho()
            cbreak()
        return key_sequence

    def input_taskids(self):
        ids = self.input_sequence("Enter the task's ids")

        while True:
            try:
                list(map(int, ids))
                return ids
            except ValueError:
                ids = self.input_sequence("Please enter valid ids")

    def draw_windows(self):
        self.stdscr.refresh()

        MAX_Y, MAX_X = self.stdscr.getmaxyx()
        STATUS_WINDOW_HEIGHT = 4
        TEXTBOX_WINDOW_HEIGHT = 4
        POMODORO_WINDOW_HEIGHT = 3
        TASK_WINDOW_HEIGHT = (MAX_Y
                              - STATUS_WINDOW_HEIGHT
                              - TEXTBOX_WINDOW_HEIGHT
                              - POMODORO_WINDOW_HEIGHT)

        self.task_window = newborderedwin(TASK_WINDOW_HEIGHT, MAX_X - 1,
                                          0, 0)
        self.pomodoro_window = newborderedwin(POMODORO_WINDOW_HEIGHT,
                                              MAX_X - 1,
                                              TASK_WINDOW_HEIGHT,
                                              0)
        self.status_window = newborderedwin(STATUS_WINDOW_HEIGHT, MAX_X - 1,
                                            TASK_WINDOW_HEIGHT
                                            + POMODORO_WINDOW_HEIGHT,
                                            0)
        self.textbox_window = newborderedwin(TEXTBOX_WINDOW_HEIGHT, MAX_X - 1,
                                             TASK_WINDOW_HEIGHT
                                             + STATUS_WINDOW_HEIGHT
                                             + POMODORO_WINDOW_HEIGHT,
                                             0)

        self.refresh_tasks()

    def refresh_tasks(self):
        self.task_window.clear()
        tasks = run_task().stdout.decode('utf-8').split("\n")

        try:
            for y, task in enumerate(tasks):
                self.task_window.addstr(y, 1, task)
        except error:
            pass

        self.task_window.refresh()

    def add(self):
        name = self.input_sequence("Enter the new task's data")
        run_task(['add'] + name.split())

    def delete(self):
        ids = self.input_taskids()
        run_task([ids, 'delete', 'rc.confirmation=off'])

    def modify(self):
        ids = self.input_taskids()
        name = self.input_sequence("Enter the modified task's data")
        run_task([ids, 'modify'] + name.split())

    def complete(self):
        ids = self.input_taskids()
        run_task([ids, 'done'])

    def custom_command(self):
        command = self.input_sequence('Enter your command')
        run_task(command.split())

    def manage_wifi(self, timer_running=False):
        if self.password is None:
            self.password = self.input_sequence('Messing with wifi. Enter your'
                                                ' password').decode('utf-8')

        if timer_running:
            child = spawn('sudo systemctl start netctl-auto@wlp2s0')
        else:
            child = spawn('sudo systemctl stop netctl-auto@wlp2s0')

        child.sendline(self.password)
        child.expect(EOF)


def main(stdscr):
    sync()
    windrawer = WinDrawer(stdscr)
    with PomodoroTimer() as pomodoro_timer:
        # (func, args)
        task_actions = {
            "KEY_RESIZE": (windrawer.draw_windows,),
            'r': (windrawer.refresh_tasks,),
            'a': (windrawer.add,),
            'd': (windrawer.delete,),
            'c': (windrawer.complete,),
            'm': (windrawer.modify,),
            '!': (windrawer.custom_command,),
            'p': (toggle_timer, windrawer, pomodoro_timer),
            's': (stop_timer, windrawer, pomodoro_timer),
            'n': (next_phase, windrawer, pomodoro_timer),
            'y': (sync, windrawer.write_status),
            'q': (app_quit, windrawer),
        }

        while True:
            try:
                windrawer.write_status('(r)efresh tasks, (a)dd task, (d)elete '
                                       'task, (c)omplete task, (m)odify, '
                                       '(!)custom command, (p)omodoro (toggle)'
                                       ', (s)top pomodoro, (n)ext pomodoro '
                                       'phase, s(y)nc server, (q)uit')

                read_char = windrawer.input_char()

                try:
                    action, *params = task_actions[read_char]
                    action(*params)
                    windrawer.refresh_tasks()
                except KeyboardInterrupt:
                    continue
                except KeyError:
                    windrawer.write_status(f'Unknown action: "{read_char}". '
                                           'Press any key to continue')
                    windrawer.input_char()

            except KeyboardInterrupt:
                app_quit(windrawer)


def app_quit(windrawer):
    sync(windrawer.write_status)
    windrawer.manage_wifi()
    quit()


try:
    wrapper(main)
except error:
    print(f'An error occured while drawing {argv[0]}. My best guess is that '
          f'the window was too small')
