#!/usr/bin/env python3

from curses import (wrapper, echo, noecho, cbreak, nocbreak, newwin, error,
                    color_pair, init_pair, COLOR_RED, COLOR_WHITE, COLOR_GREEN,
                    use_default_colors)
from logging import error as log_error, basicConfig
from os.path import expanduser, join
from pexpect import spawn, EOF
from platform import system
from subprocess import run, PIPE, STDOUT
from sys import argv
from time import sleep

from yaml import safe_load

from pomodoro import PomodoroTimer, PomodoroError


SYNC_MSG = 'Syncing task server...'

ROOT_DIR = expanduser(join('.config', 'just-start'))
CONFIG_PATH = join(ROOT_DIR, 'preferences.yml')
LOG_PATH = join(ROOT_DIR, 'log')


HELP_MESSAGE = ('(a)dd task, (c)omplete task, (d)elete task, (h)elp, s(k)ip to'
                ' another pomodoro phase, (m)odify task, (p)omodoro pause/'
                'resume, (q)uit, (r)efresh tasks, (s)top pomodoro, s(y)nc'
                ' server, (!) custom command')


class JustStartError(Exception):
    pass


def run_task(arg_list=None):
    arg_list = arg_list or []
    completed_process = run(['task'] + arg_list, stdout=PIPE, stderr=STDOUT)
    process_output = completed_process.stdout.decode('utf-8')

    if completed_process.returncode != 0:
        raise JustStartError(process_output)

    return process_output


def newborderedwin(height, width, start_y, start_x, title=''):
    borderedwindow = newwin(height, width, start_y, start_x)
    borderedwindow.clear()
    borderedwindow.border()
    borderedwindow.move(0, 2)
    borderedwindow.addstr(title)
    borderedwindow.refresh()

    return newwin(height - 2, width - 2, start_y + 1, start_x + 1)


def toggle_timer(network_handler, timer):
    timer.toggle()
    network_handler.manage_wifi(timer.is_running)


def stop_timer(network_handler, timer):
    timer.reset()
    network_handler.manage_wifi(timer_running=False)


def skip_phases(prompt_handler, network_handler, timer):
    prompt = 'Enter how many phases you want to skip'
    valid_phases = False

    while not valid_phases:
        try:
            phases = int(prompt_handler.input_sequence(prompt))
        except ValueError:
            pass
        else:
            if phases >= 1:
                timer.advance_phases(phases_skipped=phases)
                valid_phases = True
                network_handler.manage_wifi(timer_running=True)

        prompt = 'Please enter a valid number of phases'


def parse_config():
    with open(expanduser(CONFIG_PATH)) as f:
        return safe_load(f)


class WindowHandler:
    def __init__(self, stdscr):
        self.stdscr = stdscr

        use_default_colors()
        for color in COLOR_WHITE, COLOR_GREEN, COLOR_RED:
            init_pair(color, color, -1)

        self.task_window = None
        self.tasks = ''

        self.pomodoro_window = None
        self.written_pomodoro_status = ''

        self.status_window = None
        self.written_status = ''
        self.status_color = COLOR_WHITE

        self.prompt_handler = PromptHandler(self.stdscr)

        self.draw_windows()

    def draw_windows(self):
        self.stdscr.refresh()

        max_y, max_x = self.stdscr.getmaxyx()
        status_window_height = 7
        pomodoro_window_height = 7
        prompt_window_height = 6
        task_window_height = max_y - status_window_height - prompt_window_height

        self.task_window = newborderedwin(task_window_height, max_x - 1, 0, 0)
        self.refresh_tasks()

        status_window_width = int(max_x / 2)
        self.pomodoro_window = newborderedwin(pomodoro_window_height,
                                              status_window_width,
                                              task_window_height,
                                              status_window_width,
                                              'Pomodoro status')

        self.status_window = newborderedwin(status_window_height,
                                            status_window_width,
                                            task_window_height,
                                            0,
                                            'App status')

        prompt_y = task_window_height + status_window_height
        self.prompt_handler.draw_prompt_windows(prompt_y, prompt_window_height,
                                                max_x - 1, self.status_window,
                                                self.write_status)

        self.write_pomodoro_status(self.written_pomodoro_status)
        self.write_status(self.written_status, color=self.status_color)

    def write_status(self, status, color=COLOR_WHITE):
        self.prompt_handler.write_prompt('')
        self.status_window.clear()
        self.status_window.addstr(status, color_pair(color))
        self.status_window.refresh()
        self.written_status = status
        self.status_color = color

    def write_pomodoro_status(self, status):
        self.status_window.clear()
        self.pomodoro_window.clear()
        self.pomodoro_window.addstr(status)
        self.pomodoro_window.refresh()
        self.written_pomodoro_status = status

    def sync(self):
        try:
            self.write_status(SYNC_MSG)
            self.write_status(run_task(['sync']))
        except KeyboardInterrupt:
            pass

    def refresh_tasks(self):
        self.tasks = run_task().split("\n")
        self.task_window.clear()

        try:
            for y, task in enumerate(self.tasks):
                self.task_window.addstr(y, 1, task)
        except error:
            pass

        self.task_window.refresh()


class PromptHandler:
    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.written_prompt = ''
        self.prompt_color = COLOR_WHITE

        self.status_window = self.write_status = self.prompt_window = None
        self.input_window = None

    def draw_prompt_windows(self, prompt_y, prompt_height, prompt_width,
                            status_window, write_status):
        newborderedwin(prompt_height, prompt_width, prompt_y, 0)
        inner_height = int((prompt_height - 2) / 2)

        self.prompt_window = newwin(inner_height, prompt_width, prompt_y + 1, 1)

        self.input_window = newwin(inner_height,  prompt_width,
                                   prompt_y + inner_height + 1, 1)

        self.status_window = status_window
        self.write_status = write_status

        self.input_window.refresh()
        self.prompt_window.refresh()

    def write_prompt(self, prompt, color=COLOR_WHITE):
        self.status_window.clear()
        self.prompt_window.clear()
        self.prompt_window.addstr(prompt, color_pair(color))
        self.prompt_window.refresh()
        self.written_prompt = prompt

    def input_char(self):
        self.input_window.clear()
        return self.input_window.getkey(
            *self.input_window.getyx()
        )

    def input_sequence(self, status, color=COLOR_WHITE):
        self.write_prompt(status + " and press Ctrl-Enter when done (or "
                          "Ctrl-C to cancel)", color=color)
        self.input_window.clear()
        echo()
        nocbreak()

        try:
            key_sequence = self.input_window.getstr(
                *self.input_window.getyx())
        finally:
            noecho()
            cbreak()
        return key_sequence

    def input_taskids(self):
        ids = self.input_sequence("Enter the task's ids")

        while True:
            try:
                list(map(int, ids))
                return ids
            except ValueError:
                ids = self.input_sequence("Please enter valid ids",
                                          color=COLOR_RED)

    def add(self):
        name = self.input_sequence("Enter the new task's data")
        self.write_status(run_task(['add'] + name.split()))

    def delete(self):
        ids = self.input_taskids()
        self.write_status(run_task([ids, 'delete', 'rc.confirmation=off']))

    def modify(self):
        ids = self.input_taskids()
        name = self.input_sequence("Enter the modified task's data")
        self.write_status(run_task([ids, 'modify'] + name.split()))

    def complete(self):
        ids = self.input_taskids()
        self.write_status(run_task([ids, 'done']))

    def custom_command(self):
        command = self.input_sequence('Enter your command')
        self.write_status(run_task(command.split()))


class NetworkHandler:
    def __init__(self, config):
        self.password = config['password']

        blocking_lines = '\\n'.join(
            [f'127.0.0.1\\t{blocked_site}\\t#juststart\\n'
             f'127.0.0.1\\twww.{blocked_site}\\t#juststart'
             for blocked_site in config['blocked_sites']])

        self.block_command = (f'/bin/bash -c "echo -e \'{blocking_lines}\' | '
                              f'sudo tee -a /etc/hosts > /dev/null"')
        self.unblock_command = 'sudo sed -i -e /#juststart$/d /etc/hosts'

    def run_sudo(self, command):
        child = spawn(command)

        try:
            child.sendline(self.password)
            child.expect(EOF)
        except OSError:
            pass

    def manage_blocked_sites(self, blocked):
        if blocked:
            self.run_sudo(self.unblock_command)
            self.run_sudo(self.block_command)
        else:
            self.run_sudo(self.unblock_command)

    def manage_wifi(self, timer_running=False):
        if timer_running:
            if system() == 'Linux':
                self.run_sudo('sudo systemctl start netctl-auto@wlp2s0')
            else:
                self.run_sudo('networksetup -setairportpower en0 on')
        else:
            if system() == 'Linux':
                self.run_sudo('sudo systemctl stop netctl-auto@wlp2s0')
            else:
                self.run_sudo('networksetup -setairportpower en0 off')


def main(stdscr):
    stdscr.clear()

    config = parse_config()
    window_handler = WindowHandler(stdscr)
    prompt_handler = window_handler.prompt_handler
    network_handler = NetworkHandler(config)
    try:
        window_handler.sync()
    except JustStartError as exc:
        window_handler.write_status(str(exc), color=COLOR_RED)

    with PomodoroTimer(window_handler.write_pomodoro_status,
                       network_handler.manage_blocked_sites, config,
                       CONFIG_PATH) as pomodoro_timer:

        refreshing_actions = {
            'a': prompt_handler.add,
            'c': prompt_handler.complete,
            'd': prompt_handler.delete,
            'm': prompt_handler.modify,
            'y': window_handler.sync,
            '!': prompt_handler.custom_command,
        }
        non_refreshing_actions = {
            "KEY_RESIZE": (window_handler.draw_windows,),
            'h': (window_handler.write_status, HELP_MESSAGE),
            'k': (skip_phases, prompt_handler, network_handler, pomodoro_timer),
            'p': (toggle_timer, network_handler, pomodoro_timer),
            'q': (app_quit, window_handler, network_handler),
            'r': (window_handler.refresh_tasks,),
            's': (stop_timer, network_handler, pomodoro_timer),
        }

        while True:
            prompt_handler.write_prompt('Waiting for user. Pressing h shows'
                                        ' available actions')

            try:
                read_char = prompt_handler.input_char()
                window_handler.write_status('')
                sleep(0.1)

                try:
                    try:
                        refreshing_actions[read_char]()
                    except KeyError:
                        try:
                            action, *params = non_refreshing_actions[read_char]
                            action(*params)
                        except (PomodoroError, JustStartError) as exc:
                            window_handler.write_status(str(exc),
                                                        color=COLOR_RED)
                    else:
                        window_handler.refresh_tasks()

                except KeyboardInterrupt:
                    continue
                except KeyError:
                    window_handler.write_status(f'Unknown key action:'
                                                f' "{read_char}"',
                                                color=COLOR_RED)

            except KeyboardInterrupt:
                window_handler.write_status(f'Please use q to quit',
                                            color=COLOR_RED)
            except JustStartError as exc:
                window_handler.write_status(str(exc), color=COLOR_RED)


def app_quit(window_handler, network_handler):
    try:
        window_handler.sync()
    except JustStartError as exc:
        window_handler.write_status(str(exc), color=COLOR_RED)
    network_handler.manage_wifi()
    quit()


if __name__ == '__main__':
    def log(error_):
        log_error(f'{type(error_)}: {error_}')
        print(f'Log written at "{LOG_PATH}"')
    try:
        basicConfig(filename=LOG_PATH)
        wrapper(main)
    except error as e:
        print(f'An error occurred while drawing {argv[0]}. My best guess is'
              f' that the window was too small.', end=' ')
        log(e)
    except Exception as e:
        print(f'Unhandled error.', end=' ')
        log(e)
